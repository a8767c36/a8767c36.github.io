The concept of time is negligible for concepts of sustainable systems.
Time is the implication of yin in TCM, it is the inertia of massive objects
and it is represented by invariances in my theory.
Though subject of (these here) considerations is not the essence of time,
but its implementation:
Devising the general structure for an organism implies dealing with time itself.
I propose a theory that does not have "dead code".

When we design programs, we build them from building blocks, so called elements.
These elements, in turn, aren't atomic but built from elements.
Extending the recursion we should consider programs as elements.
The structure of a building block of the system must correspond to the structure of the program.
Therefore, a program isn't closed in itself but explicitely woven into its environment.

The second law of thermodynamics requires that the entropy of any system increases over time.
To aid the fact that any organism would heat up enough to burn itself,
we must implement "forgetting", or some kind of resetting. (That can't be defined as explicit filter while the requirements are unknown.)
I propose that if a network of information processing evolves, then also the overall program needs to evolve. Therefore, also the filters need to evolve.
I hereby propose implementing filters as further information processing steps. Therefore, filters have no "active parts" in themselves,
so external feedback is required. A program needs to be woven into its environment.
Since filters are merely further steps of information processing, we don't have to explicitely define them.

ENVIRONMENT {
  PROGRAM
}
where PROGRAM is SOMESTRUCTURE<SOMESTRUCTURE<SOMESTRUCTURE<...>>>
so the question is: what is SOMESTRUCTURE?
I'd say it depends on the environment...
So what are our requirements for the system?

We want.
(whatever)
Therefore, we can define "good" and "bad".
Then, we can define SOMESTRUCTURE as evolution: mutation and selection (in some (abstract) variant).
So a net consists of components that can be "good" or "bad".
So giving feedback to the system, the system gives feedback to the individual components.
Just that components aren't necessarily clearly defined by borders. But the program is neither.
So, to add a component isn't a discrete step, but an amorph step: What is a component?
We can evolve that too... (as is a clear implication of recursivity)
So we have chunks of information processing (IP) that yield packets that can also stand for a structure of components.
